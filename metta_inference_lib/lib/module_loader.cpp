#include "metta_inference/module_loader.hpp"
#include "metta_inference/config.hpp"  // For Constants
#include <iostream>
#include <fstream>
#include <algorithm>
#include <chrono>
#include <unistd.h>

namespace metta_inference {

std::vector<fs::path> ModuleLoader::scanMettaFiles(const fs::path& directory) {
    std::vector<fs::path> files;
    
    if (!fs::exists(directory) || !fs::is_directory(directory)) {
        return files;
    }
    
    std::error_code ec;
    for (const auto& entry : fs::directory_iterator(directory, ec)) {
        if (ec) {
            std::cerr << "Warning: Error accessing file in " << directory 
                     << ": " << ec.message() << "\n";
            continue;
        }
        
        if (entry.is_regular_file() && entry.path().extension() == ".metta") {
            // Check file size before adding
            auto fileSize = fs::file_size(entry.path(), ec);
            if (!ec) {
                const size_t maxSize = Constants::MAX_FILE_SIZE_MB * 1024 * 1024;
                if (fileSize > maxSize) {
                    std::cerr << "Warning: Skipping large file " << entry.path().filename() 
                             << " (" << fileSize / (1024 * 1024) << " MB)\n";
                    continue;
                }
                files.push_back(entry.path());
            } else {
                std::cerr << "Warning: Cannot check size of " << entry.path().filename() 
                         << ": " << ec.message() << "\n";
            }
        }
    }
    
    std::sort(files.begin(), files.end());
    return files;
}

ModuleLoader::ModuleInfo ModuleLoader::analyzeModule(const fs::path& directory) {
    ModuleInfo info;
    info.path = directory;
    info.files = scanMettaFiles(directory);
    
    for (const auto& file : info.files) {
        std::error_code ec;
        auto size = fs::file_size(file, ec);
        if (!ec) {
            info.totalSize += size;
        }
    }
    
    return info;
}

fs::path ModuleLoader::createCombinedFile(
    const std::vector<fs::path>& modulePaths,
    const fs::path& exampleFile,
    bool verbose) {
    
    fs::path tempFile = fs::temp_directory_path() / 
                       ("metta_combined_" + std::to_string(getpid()) + ".metta");
    
    std::ofstream outFile(tempFile);
    if (!outFile.is_open()) {
        throw std::runtime_error("Failed to create combined file: " + tempFile.string());
    }
    
    size_t totalFiles = 0;
    size_t totalSize = 0;
    
    outFile << ";; Combined MeTTa file generated by inference runner\n";
    outFile << ";; Generated: " << std::chrono::system_clock::now().time_since_epoch().count() << "\n\n";
    
    for (size_t i = 0; i < modulePaths.size(); ++i) {
        const auto& modulePath = modulePaths[i];
        auto moduleInfo = analyzeModule(modulePath);
        
        if (moduleInfo.files.empty()) {
            if (verbose) {
                std::cout << "  Warning: No .metta files found in " << modulePath << "\n";
            }
            continue;
        }
        
        outFile << ";; ========== Module " << (i + 1) << ": " << modulePath.filename() 
               << " (" << moduleInfo.files.size() << " files) ==========\n\n";
        
        for (const auto& file : moduleInfo.files) {
            outFile << ";; -- File: " << file.filename() << " --\n";
            
            std::ifstream inFile(file);
            if (!inFile.is_open()) {
                std::cerr << "Warning: Failed to read module file: " << file << "\n";
                continue;
            }
            
            // Check file size again before reading
            std::error_code sizeEc;
            auto fileSize = fs::file_size(file, sizeEc);
            if (!sizeEc && fileSize > Constants::MAX_FILE_SIZE_MB * 1024 * 1024) {
                std::cerr << "Warning: Skipping oversized file: " << file << "\n";
                inFile.close();
                continue;
            }
            
            outFile << inFile.rdbuf();
            outFile << "\n\n";
            
            totalFiles++;
            std::error_code ec;
            auto size = fs::file_size(file, ec);
            if (!ec) totalSize += size;
            
            if (verbose) {
                std::cout << "    Added: " << file.filename() << " (" << size << " bytes)\n";
            }
        }
    }
    
    outFile << ";; ========== Example File ==========\n\n";
    outFile << ";; -- File: " << exampleFile.filename() << " --\n";
    
    // Validate example file size
    std::error_code exampleEc;
    auto exampleSize = fs::file_size(exampleFile, exampleEc);
    if (!exampleEc && exampleSize > Constants::MAX_FILE_SIZE_MB * 1024 * 1024) {
        throw std::runtime_error("Example file too large: " + std::to_string(exampleSize / (1024 * 1024)) + " MB");
    }
    
    std::ifstream exampleIn(exampleFile);
    if (!exampleIn.is_open()) {
        throw std::runtime_error("Failed to read example file: " + exampleFile.string());
    }
    
    outFile << exampleIn.rdbuf();
    outFile << "\n";
    
    outFile.close();
    
    if (verbose) {
        std::cout << "  Combined " << totalFiles << " module files + example (" 
                 << totalSize << " bytes total)\n";
    }
    
    return tempFile;
}

std::vector<ModuleLoader::ModuleInfo> ModuleLoader::validateModules(
    const std::vector<fs::path>& modulePaths) {
    
    std::vector<ModuleInfo> modules;
    
    for (const auto& path : modulePaths) {
        auto info = analyzeModule(path);
        modules.push_back(info);
        
        if (!fs::exists(path)) {
            throw std::runtime_error("Module directory not found: " + path.string());
        }
        
        if (!fs::is_directory(path)) {
            throw std::runtime_error("Module path is not a directory: " + path.string());
        }
    }
    
    return modules;
}

}